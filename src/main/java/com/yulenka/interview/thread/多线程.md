
### 怎么更好的理解多线程？以及多线程返回值的由来？
其实就是1个进程有多个任务要做，把他们分解成多线程，每个线程负责1个任务，独立运行；
有个问题就出来了：会出现同步问题，就是谁先谁后做完不确定；
### 所以多线程的返回值怎么处理？
假设某个主线程依赖子线程的结果(也就是返回值)才能继续执行，需要怎么做？
解决方法有点类似Linux下的5种I/O模型；
1）主线成循环等待判断，while（sonThread.value == null）;
2）sonThread.join（）方法，阻塞主线成等待子线程执行完毕！
3) 实现Callable接口；FutureTask 或者用线程池
其实一步步下来，粒度是越来越细的；



### wait和sleep的区别
1.
Thread.sleep()只会让出CPU，不会导致锁行为的改变；

Object.wait()不仅让出CPU，还会释放已经占有的同步资源锁！
2.
sleep在任何地方使用，而wait只能在synchronized块种执行；

### notify 与notifyall区别
唤醒等待池的1个or 全部，放入锁池中；


### yeild
线程让出CPU，暗示，但是不一定真让出！



### 中断线程
抛弃野蛮的stop（），采用interrupt（）方法



### synchronized （互斥锁）
共享资源需要锁住，防止多线程互相影响
堆是共享的部分，所以锁的是堆中的对象；
获取对象锁的2种方法：
1）同步代码块：synchronized(this),synchronized(对象);
2) 同步非静态方法 synchronized method ，锁的是当前对象的实例对象
锁的是对象时，不同对象互不影响；
获取类锁的2种方法：
1.synchronized(Object.class)
2.static synchronized method()
类锁其实就是更加特殊化的对象锁,
在都是从同一个类中实例化的对象，但是类锁和对象锁互不干扰！

### 底层实现原理
对象头中的monitor对象，C++实现，存在于每个对象中，所以每个对象都可以当锁！
看class文件得知实现指令：monitorenter  （代码）  monitorexit、

### 可重入的！


### JDK6以后，synchronized 性能得到很大的提升！
自旋锁：
    共享数据锁定状态持续时间短，切换线程不值得；
    通过让线程执行忙循环等待锁的释放，不让出CPU；
    
自适应自旋锁：
    自旋的次数不再固定，根据前次在同一个锁上的自旋时间以及锁的拥有者的状态来决定；
   
   锁消除：
JIT的优化，消除不存在竞争关系的锁
        
        
###  synchronized的四种状态
锁膨胀状态：无锁-》偏向锁-》轻量级锁-》重量级锁
